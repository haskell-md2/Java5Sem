# Структура сжатого файла формата `.huff`

Ниже описан бинарный формат выходного файла, который создаёт данная программа при сжатии (`-co`). Формат читается последовательно, без «магического числа» или явного поля длины для блока данных.

## Общий порядок полей

Сжатый файл состоит из четырёх логических частей, идущих строго подряд в потоке битов (без обязательного выравнивания на границы байта между частями):

1. Заголовок с именем исходного файла  
2. Поле с длиной исходного файла в байтах  
3. Закодированное описание дерева Хаффмана  
4. Поток закодированных данных исходного файла  

## 1. Заголовок: имя исходного файла

1. Поле `filenameLength` — длина имени файла в байтах.  
   - Тип: 32‑битное знаковое целое (`int`).  
   - Порядок битов: 32 бита, от старшего (bit 31) к младшему (bit 0).  
   - Запись: `IOhelpers.writeInt(bos, filenameLength)`.  
   - Чтение: `IOhelpers.readInt(bis)`.  

2. Поле `filenameBytes` — байты имени файла в UTF‑8.  
   - Размер: `filenameLength` байт.  
   - Каждый байт пишется как 8 бит от старшего к младшему через `IOhelpers.writeByte`.  
   - Читается по одному байту через `IOhelpers.readByte` в массив `filenameBytes`, затем создаётся строка `originalFilename`.  

После чтения этих полей декодер создаёт выходной файл с именем `originalFilename`.

## 2. Длина исходного файла

Следующее поле — `originalSize` — длина исходного несжатого файла в байтах.

- Тип: 32‑битное знаковое целое (`int`).  
- Порядок битов: 32 бита, от старшего к младшему.  
- Запись при сжатии: `IOhelpers.writeInt(bos, (int) fis.getChannel().size());`.  
- Чтение при распаковке: `int originalSize = IOhelpers.readInt(bis);`.  

Это поле используется декодером для того, чтобы остановить восстановление данных после записи ровно `originalSize` байт, игнорируя паддинг в конце битового потока.

## 3. Описание дерева Хаффмана

Далее идёт сериализованное дерево Хаффмана в префиксной форме (обход в глубину: корень → левое поддерево → правое поддерево).

Для каждого узла:

- Если узел — лист:  
  1. Записывается один бит `1`.  
  2. Следом один байт `symbol` (8 бит от старшего к младшему) — байтовое значение символа исходного файла.  

- Если узел — внутренний:  
  1. Записывается один бит `0`.  
  2. Рекурсивно записываются левый и правый потомки в том же формате.  

Запись выполняется методами `HuffmanTree.writeTree` и `writeNode`, чтение — `HuffmanTree.readTree` и `readNode`, которые восстанавливают структуру дерева из потока битов.

## 4. Закодированные данные

Сразу после последнего бита дерева начинается поток кодов Хаффмана для байтов исходного файла.

- Для каждого байта исходного файла выбирается его код Хаффмана (строка из `'0'` и `'1'`), сгенерированная в `HuffmanTree.buildCodes`.  
- Все коды последовательно записываются в `BitOutputStream` методом `writeBit` без разделителей и отдельных полей длины битового потока.  
- При распаковке из `BitInputStream` читаются биты по одному, происходит спуск по дереву (бит `0` — влево, `1` — вправо); при достижении листа в выходной файл записывается соответствующий байт, а текущий узел сбрасывается на корень.  

Окончание данных при распаковке определяется не EOF, а счётчиком восстановленных байт: декодер останавливает чтение, когда количество записанных байт достигает `originalSize`, который был прочитан из заголовка.
