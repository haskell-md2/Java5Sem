# Структура сжатого файла формата `.huff`

Ниже описан бинарный формат выходного файла, который создаёт данная программа при сжатии (`-co`). Формат читается последовательно, без «магического числа» или явных полей длины для блока данных.

## Общий порядок полей

Сжатый файл состоит из трёх логических частей, идущих строго подряд в потоке битов (без выравнивания на байты между частями):

1. Заголовок с именем исходного файла  
2. Закодированное описание дерева Хаффмана  
3. Поток закодированных данных исходного файла  

## 1. Заголовок: имя исходного файла

1. Поле `filenameLength` — длина имени файла в байтах.  
   - Тип: 32-битное знаковое целое (`int`).  
   - Порядок битов: записывается как 32 бита, начиная со старшего бита (bit 31) к младшему (bit 0).  
   - Для записи используется `IOhelpers.writeInt`, для чтения — `IOhelpers.readInt`.

2. Поле `filenameBytes` — само имя файла в UTF‑8.  
   - Размер: `filenameLength` байт.  
   - Каждый байт пишется как 8 бит от старшего к младшему через `IOhelpers.writeByte`, читается через `IOhelpers.readByte`.

После чтения этих полей декодер получает строку `originalFilename` и создаёт выходной файл с этим именем.

## 2. Описание дерева Хаффмана

Далее в потоке битов записано дерево Хаффмана в префиксной форме (обход в глубину, корень → левое поддерево → правое поддерево). Структура:

- Для каждого узла:
  - Если узел — лист:
    1. Записывается один бит `1`.  
    2. Следом записывается один байт `symbol` (8 бит от старшего к младшему), соответствующий байтовому значению символа исходного файла.
  - Если узел — внутренний:
    1. Записывается один бит `0`.  
    2. Рекурсивно записывается левый потомок.  
    3. Рекурсивно записывается правый потомок.

Таким образом, структура дерева полностью восстанавливается по последовательности битов, читаемой функцией `HuffmanTree.readTree` / `readNode`.

## 3. Закодированные данные

Сразу после последнего бита дерева начинается поток сжатых данных исходного файла:

- Для каждого байта исходного файла берётся его код Хаффмана (строка из символов `'0'` и `'1'`), построенная в `HuffmanTree.buildCodes`.  
- Эти коды последовательно записываются побитово через `BitOutputStream.writeBit` без каких‑либо разделителей или явного указания длины.
- При декодировании читаются биты по одному, выполняется спуск по восстановленному дереву (0 — влево, 1 — вправо). Каждое достижение листа порождает один байт, который сразу записывается в выходной файл.

Окончание данных определяется исчерпанием входного потока: чтение битов продолжается до тех пор, пока `BitInputStream.readBit()` не вернёт `-1` (EOF). Специального маркера конца данных или явного поля длины исходного файла формат не содержит.